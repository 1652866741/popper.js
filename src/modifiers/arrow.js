import getPopperClientRect from '../utils/getPopperClientRect';
import getOuterSizes from '../utils/getOuterSizes';
import isModifierRequired from '../utils/isModifierRequired';

/**
 * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
 * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
export default function arrow(data) {
    var arrow  = data.instance._options.arrowElement;

    // if the arrowElement is a string, suppose it's a CSS selector
    if (typeof arrow === 'string') {
        arrow = data.instance._popper.querySelector(arrow);
    }

    // if arrow element is not found, don't run the modifier
    if (!arrow) {
        return data;
    }

    // the arrow element must be child of its popper
    if (!data.instance._popper.contains(arrow)) {
        console.warn('WARNING: `arrowElement` must be child of its popper element!');
        return data;
    }

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance._options, 'arrow', 'keepTogether')) {
        console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
        return data;
    }

    var arrowStyle  = {};
    var placement   = data.placement.split('-')[0];
    var popper      = getPopperClientRect(data.offsets.popper);
    var reference   = data.offsets.reference;
    var isVertical  = ['left', 'right'].indexOf(placement) !== -1;

    var len         = isVertical ? 'height' : 'width';
    var side        = isVertical ? 'top' : 'left';
    var altSide     = isVertical ? 'left' : 'top';
    var opSide      = isVertical ? 'bottom' : 'right';
    var arrowSize   = getOuterSizes(arrow)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
    }
    // bottom/right side
    if (reference[side] + arrowSize > popper[opSide]) {
        data.offsets.popper[side] += (reference[side] + arrowSize) - popper[opSide];
    }

    // compute center of the popper
    var center = reference[side] + (reference[len] / 2) - (arrowSize / 2);

    // Compute the sideValue using the updated popper offsets
    var sideValue = center - getPopperClientRect(data.offsets.popper)[side];

    // prevent arrow from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowSize, sideValue), 0);
    arrowStyle[side] = sideValue;
    arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

    data.offsets.arrow = arrowStyle;
    data.arrowElement = arrow;

    return data;
}
