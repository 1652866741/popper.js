import getPopperClientRect from '../utils/getPopperClientRect';
import getOuterSizes from '../utils/getOuterSizes';
import isModifierRequired from '../utils/isModifierRequired';

/**
 * Modifier used to move the arrowEls on the edge of the popper to make sure them are always between the popper and the reference element
 * It will use the CSS outer size of the arrowEl element to know how many pixels of conjuction are needed
 * @method
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
export default function arrow(data, options) {
    let arrowEl  = options.element;

    // if the arrowElElement is a string, suppose it's a CSS selector
    if (typeof arrowEl === 'string') {
        arrowEl = data.instance.popper.querySelector(arrowEl);
    }

    // if arrowEl element is not found, don't run the modifier
    if (!arrowEl) {
        return data;
    }

    // the arrowEl element must be child of its popper
    if (!data.instance.popper.contains(arrowEl)) {
        console.warn('WARNING: `arrowElElement` must be child of its popper element!');
        return data;
    }

    // arrowEl depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
        return data;
    }

    const arrowElStyle  = {};
    const placement     = data.placement.split('-')[0];
    const popper        = getPopperClientRect(data.offsets.popper);
    const reference     = data.offsets.reference;
    const isVertical    = ['left', 'right'].indexOf(placement) !== -1;

    const len           = isVertical ? 'height' : 'width';
    const side          = isVertical ? 'top' : 'left';
    const altSide       = isVertical ? 'left' : 'top';
    const opSide        = isVertical ? 'bottom' : 'right';
    const arrowElSize   = getOuterSizes(arrowEl)[len];

    //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowElSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElSize);
    }
    // bottom/right side
    if (reference[side] + arrowElSize > popper[opSide]) {
        data.offsets.popper[side] += (reference[side] + arrowElSize) - popper[opSide];
    }

    // compute center of the popper
    const center = reference[side] + (reference[len] / 2) - (arrowElSize / 2);

    // Compute the sideValue using the updated popper offsets
    let sideValue = center - getPopperClientRect(data.offsets.popper)[side];

    // prevent arrowEl from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElSize, sideValue), 0);
    arrowElStyle[side] = sideValue;
    arrowElStyle[altSide] = ''; // make sure to remove any old style from the arrowEl

    data.offsets.arrow = arrowElStyle;
    data.arrowElement = arrowEl;

    return data;
}
